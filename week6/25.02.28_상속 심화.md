# C++ 객체지향 프로그래밍 핵심 개념

## 1. is-a 관계와 has-a 관계

### is-a 관계 (상속)
- **정의**: 한 클래스가 다른 클래스의 모든 기능을 포함하고, 그 클래스로 취급될 수 있는 관계
- **예시**: `Manager` is a `Employee`
- **구현 방법**: 상속을 통해 구현
```cpp
class Employee { /* ... */ };
class Manager : public Employee { /* ... */ };
```
- **특징**:
  - 파생 클래스는 기반 클래스로 취급될 수 있음 (업캐스팅 가능)
  - 기반 클래스는 파생 클래스로 취급될 수 없음
  - 클래스가 파생될수록 더 특수화/구체화(specialize)됨
  - 기반 클래스로 올라갈수록 더 일반화(generalize)됨

### has-a 관계 (포함)
- **정의**: 한 클래스가 다른 클래스의 객체를 멤버로 포함하는 관계
- **예시**: `Car` has a `Engine`, `EmployeeList` has a `Employee`
- **구현 방법**: 클래스 내에 다른 클래스의 객체를 멤버 변수로 포함
```cpp
class Engine { /* ... */ };
class Car {
private:
    Engine e;
    // ...
};
```

## 2. 오버라이딩(Overriding)

- **정의**: 파생 클래스에서 기반 클래스의 메서드를 재정의하는 것
- **목적**: 같은 이름의 함수지만 파생 클래스에서 다른 동작을 구현
- **예시**:
```cpp
class Base {
public:
    void what() { std::cout << "Base Class" << std::endl; }
};

class Derived : public Base {
public:
    void what() { std::cout << "Derived Class" << std::endl; }  // 오버라이딩
};
```

## 3. 가상 함수(Virtual Function)와 virtual 키워드

- **정의**: 파생 클래스에서 재정의할 것으로 기대되는 기반 클래스의 메서드
- **구현 방법**: 함수 선언 앞에 `virtual` 키워드 사용
```cpp
class Base {
public:
    virtual void what() { std::cout << "Base Class" << std::endl; }
};
```

- **동작 원리**:
  - 가상 함수 테이블(vtable)을 통해 구현
  - 실행 시간(런타임)에 어떤 함수를 호출할지 결정 (동적 바인딩)
  - 객체의 실제 타입에 따라 적절한 함수가 호출됨

### override 키워드 (C++11)
- **용도**: 파생 클래스의 함수가 기반 클래스의 가상 함수를 오버라이드함을 명시적으로 표시
- **이점**: 실수로 오버라이드하지 않는 경우를 컴파일 시간에 감지 가능
```cpp
class Derived : public Base {
public:
    void what() override { std::cout << "Derived Class" << std::endl; }
};
```

## 4. 다형성(Polymorphism)

- **정의**: 동일한 인터페이스로 다양한 타입의 객체를 다룰 수 있는 능력
- **구현 방법**: 가상 함수와 포인터/참조를 통한 동적 바인딩
- **예시**:
```cpp
void printInfo(Employee* emp) {
    emp->print_info();  // Employee 또는 Manager의 print_info가 호출됨
}

// 사용 예
Employee* emp1 = new Employee(...);
Employee* emp2 = new Manager(...);  // 업캐스팅

printInfo(emp1);  // Employee::print_info() 호출
printInfo(emp2);  // Manager::print_info() 호출
```

- **다형성의 이점**:
  - 코드 재사용성 증가
  - 확장성 향상
  - 유지보수 용이성
  - 인터페이스와 구현의 분리

## 5. 캐스팅(Casting)

### 업캐스팅(Upcasting)
- **정의**: 파생 클래스의 포인터/참조를 기반 클래스의 포인터/참조로 변환
- **특징**: 암시적 변환 가능, 안전함
```cpp
Manager* m = new Manager();
Employee* e = m;  // 업캐스팅: 암시적 변환
```

### 다운캐스팅(Downcasting)
- **정의**: 기반 클래스의 포인터/참조를 파생 클래스의 포인터/참조로 변환
- **특징**: 명시적 변환 필요, 안전하지 않을 수 있음
```cpp
Employee* e = new Manager();
Manager* m = static_cast<Manager*>(e);  // 다운캐스팅: 명시적 변환 필요
```

### dynamic_cast
- **용도**: 런타임에 안전한 다운캐스팅
- **특징**: RTTI(Run-Time Type Information)를 사용, 실패 시 nullptr 반환(포인터) 또는 예외 발생(참조)
- **조건**: 클래스에 가상 함수가 최소 하나 이상 있어야 함(다형적 클래스)
```cpp
Employee* e = new Manager();
Manager* m = dynamic_cast<Manager*>(e);  // 성공
Employee* e2 = new Employee();
Manager* m2 = dynamic_cast<Manager*>(e2);  // 실패: nullptr 반환
```

## 6. 가상 소멸자(Virtual Destructor)

- **필요성**: 기반 클래스 포인터로 파생 클래스 객체를 삭제할 때 파생 클래스의 소멸자가 호출되도록 함
- **문제 상황**: 
```cpp
Employee* e = new Manager();
delete e;  // 가상 소멸자가 없으면 Manager의 소멸자가 호출되지 않음
```
- **해결책**: 기반 클래스의 소멸자를 가상 함수로 선언
```cpp
class Employee {
public:
    virtual ~Employee() { /* 정리 작업 */ }
};
```

## 7. 순수 가상 함수와 추상 클래스

### 순수 가상 함수(Pure Virtual Function)
- **정의**: 구현이 없고 파생 클래스에서 반드시 오버라이드해야 하는 함수
- **선언 방법**: `virtual 반환타입 함수이름() = 0;`
```cpp
class Shape {
public:
    virtual double area() = 0;  // 순수 가상 함수
};
```

### 추상 클래스(Abstract Class)
- **정의**: 하나 이상의 순수 가상 함수를 포함하는 클래스
- **특징**: 
  - 객체를 직접 생성할 수 없음
  - 파생 클래스의 기본 인터페이스 역할
  - 모든 순수 가상 함수를 오버라이드하지 않으면 파생 클래스도 추상 클래스가 됨
```cpp
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() override { return 3.14 * radius * radius; }
};
```

## 8. 다중 상속과 문제점

### 다중 상속(Multiple Inheritance)
- **정의**: 한 클래스가 둘 이상의 기반 클래스를 상속받는 것
```cpp
class A { /* ... */ };
class B { /* ... */ };
class C : public A, public B { /* ... */ };
```

### 다이아몬드 문제(Diamond Problem)
- **문제**: 동일한 기반 클래스가 여러 경로로 상속될 때 발생
```
    A
   / \
  B   C
   \ /
    D
```
- **문제점**: D에서 A의 멤버를 참조할 때 모호성 발생
- **해결책**: 가상 상속(virtual inheritance) 사용
```cpp
class B : virtual public A { /* ... */ };
class C : virtual public A { /* ... */ };
class D : public B, public C { /* ... */ };
```

## 9. 면접에서 자주 묻는 질문

### Q1: 가상 함수의 작동 원리를 설명해보세요.
**A**: 가상 함수는 vtable(가상 함수 테이블)과 vptr(가상 함수 테이블 포인터)을 통해 구현됩니다. 클래스에 가상 함수가 있으면 컴파일러는 해당 클래스에 대한 vtable을 생성하고, 각 객체에는 이 vtable을 가리키는 vptr이 추가됩니다. 함수 호출 시 vptr을 통해 vtable에 접근하여 적절한 함수를 찾아 호출합니다. 이런 메커니즘을 통해 런타임에 객체의 실제 타입에 따라 적절한 함수가 호출되는 동적 바인딩이 가능해집니다.

### Q2: virtual 키워드를 사용하지 않으면 어떤 문제가 발생할 수 있나요?
**A**: virtual 키워드를 사용하지 않으면 정적 바인딩이 발생합니다. 이 경우 포인터나 참조의 컴파일 타임 타입에 따라 함수가 결정되어, 포인터가 실제로 가리키는 객체의 타입과 무관하게 기반 클래스의 함수가 호출됩니다. 이로 인해 다형성이 제대로 작동하지 않고, 파생 클래스에서 오버라이드한 함수가 호출되지 않아 예상치 못한 동작이 발생할 수 있습니다.

### Q3: 소멸자를 가상으로 선언해야 하는 이유는 무엇인가요?
**A**: 기반 클래스 포인터로 파생 클래스 객체를 삭제할 때, 소멸자가 가상이 아니면 기반 클래스의 소멸자만 호출됩니다. 이로 인해 파생 클래스의 자원이 제대로 해제되지 않아 메모리 누수가 발생할 수 있습니다. 소멸자를 가상으로 선언하면 객체의 실제 타입에 맞는 소멸자가 호출되어 모든 자원이 올바르게 해제됩니다.

### Q4: override와 overload의 차이점을 설명해보세요.
**A**: 
- **오버라이드(Override)**: 파생 클래스에서 기반 클래스의 가상 함수를 재정의하는 것입니다. 함수 시그니처(이름, 매개변수 타입, 반환 타입)가 정확히 일치해야 합니다.
- **오버로드(Overload)**: 같은 클래스 내에서 이름은 같지만 매개변수 목록이 다른 여러 함수를 정의하는 것입니다.

### Q5: dynamic_cast와 static_cast의 차이점을 설명해보세요.
**A**:
- **dynamic_cast**: 런타임에 타입 체크를 수행하며, 안전한 다운캐스팅을 위해 사용됩니다. 실패 시 포인터의 경우 nullptr, 참조의 경우 std::bad_cast 예외를 반환합니다. 다형적 클래스(가상 함수가 있는 클래스)에서만 사용 가능합니다.
- **static_cast**: 컴파일 타임에 수행되며, 암시적 변환이 가능한 타입 간 변환을 명시적으로 지시합니다. 런타임 타입 체크를 수행하지 않아 dynamic_cast보다 빠르지만, 안전성이 떨어집니다.

### Q6: 추상 클래스와 인터페이스의 차이점은 무엇인가요?
**A**: C++에서는 Java나 C#처럼 엄밀한 `interface` 키워드는 없지만, 개념적으로 인터페이스와 추상 클래스를 구현할 수 있습니다.

**인터페이스**:
- C++에서는 모든 멤버 함수가 순수 가상 함수이고 데이터 멤버가 없는 추상 클래스로 구현됩니다.
- 오직 메서드의 시그니처만 정의하고 구현은 포함하지 않습니다.
- "무엇을 할 수 있는가"를 정의합니다 (능력/기능 중심).
- 예시:
```cpp
class Drawable {
public:
    virtual void draw() = 0;
    virtual ~Drawable() = default;  // 가상 소멸자
};
```

**추상 클래스**:
- 하나 이상의 순수 가상 함수를 포함하는 클래스입니다.
- 일부 메서드는 구현을 포함할 수 있으며, 데이터 멤버를 가질 수 있습니다.
- "무엇인가"를 정의합니다 (정체성 중심).
- 예시:
```cpp
class Shape {
protected:
    int x, y;  // 데이터 멤버

public:
    Shape(int x, int y) : x(x), y(y) {}
    
    // 일부 구현된 메서드
    void moveTo(int newX, int newY) {
        x = newX;
        y = newY;
    }
    
    // 순수 가상 함수
    virtual double area() = 0;
    virtual void draw() = 0;
    
    virtual ~Shape() = default;
};
```

**주요 차이점**:
1. **구현 여부**: 인터페이스는 구현이 없지만, 추상 클래스는 일부 메서드에 구현이 있을 수 있습니다.
2. **데이터 멤버**: 인터페이스는 데이터 멤버를 가지지 않지만, 추상 클래스는 가질 수 있습니다.
3. **목적**: 인터페이스는 클래스에 특정 기능을 추가하는 것이 목적이고, 추상 클래스는 관련 클래스들의 공통 기반을 제공하는 것이 목적입니다.
4. **다중 상속**: C++에서는 다중 상속이 가능하므로 여러 인터페이스를 구현할 수 있습니다. 이는 "다중 인터페이스 구현"의 장점을 제공합니다.

**사용 시기**:
- **인터페이스**: 관련 없는 클래스들이 공통 기능을 구현해야 할 때 사용합니다 (예: `Printable`, `Serializable`).
- **추상 클래스**: 관련된 클래스들이 공통 기능과 속성을 공유해야 할 때 사용합니다 (예: `Shape`는 `Circle`, `Rectangle`의 공통 기반).

### Q7: C++에서 다중 상속의 문제점과 해결 방법을 설명해보세요.
**A**: 다중 상속의 주요 문제점은 다이아몬드 문제입니다. 이는 두 클래스가 같은 기반 클래스를 상속받고, 또 다른 클래스가 이 두 클래스를 상속받을 때 발생합니다. 이로 인해 기반 클래스의 멤버가 중복되어 모호성이 발생합니다. 해결책으로는 가상 상속(virtual inheritance)을 사용하여 기반 클래스의 인스턴스가 단 하나만 존재하도록 할 수 있습니다.

### Q8: 다형성의 장점과 단점을 설명해보세요.
**A**:
- **장점**:
  - 코드 재사용성 증가
  - 확장성 향상
  - 인터페이스와 구현의 분리
  - 유지보수 용이성
  
- **단점**:
  - 가상 함수 호출의 오버헤드로 인한 성능 저하
  - vtable과 vptr로 인한 메모리 사용량 증가
  - 디버깅의 복잡성 증가
  - 설계의 복잡성 증가

### Q9: C++의 RTTI(Run-Time Type Information)에 대해 설명해보세요.
**A**: RTTI는 프로그램 실행 중에 객체의 타입을 확인할 수 있는 C++의 기능입니다. 주요 구성 요소는 다음과 같습니다:
- **dynamic_cast**: 안전한 다운캐스팅을 위해 사용
- **typeid 연산자**: 객체의 실제 타입 정보를 반환
- **std::type_info 클래스**: 타입 정보를 저장하는 클래스

RTTI는 가상 함수를 가진 클래스에서만 객체의 실제 타입을 정확히 판별할 수 있습니다.

### Q10: final 키워드(C++11)의 용도를 설명해보세요.
**A**: final 키워드는 두 가지 용도로 사용됩니다:
1. **클래스에 사용**: 해당 클래스가 더 이상 상속될 수 없음을 명시
   ```cpp
   class Base final { /* ... */ };
   ```
2. **가상 함수에 사용**: 파생 클래스에서 해당 함수를 오버라이드할 수 없음을 명시
   ```cpp
   virtual void func() final { /* ... */ };
   ```
이를 통해 의도하지 않은 상속이나 오버라이딩을 방지하여 설계의 안정성을 높일 수 있습니다.
