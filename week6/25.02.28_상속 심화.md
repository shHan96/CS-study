# C++ 객체지향 프로그래밍 핵심 개념

## 1. is-a 관계와 has-a 관계

### is-a 관계 (상속)
- **정의**: 한 클래스가 다른 클래스의 모든 기능을 포함하고, 그 클래스로 취급될 수 있는 관계
- **예시**: `Manager` is a `Employee`
- **구현 방법**: 상속을 통해 구현
```cpp
class Employee { /* ... */ };
class Manager : public Employee { /* ... */ };
```
- **특징**:
  - 파생 클래스는 기반 클래스로 취급될 수 있음 (업캐스팅 가능)
  - 기반 클래스는 파생 클래스로 취급될 수 없음
  - 클래스가 파생될수록 더 특수화/구체화(specialize)됨
  - 기반 클래스로 올라갈수록 더 일반화(generalize)됨

### has-a 관계 (포함)
- **정의**: 한 클래스가 다른 클래스의 객체를 멤버로 포함하는 관계
- **예시**: `Car` has a `Engine`, `EmployeeList` has a `Employee`
- **구현 방법**: 클래스 내에 다른 클래스의 객체를 멤버 변수로 포함
```cpp
class Engine { /* ... */ };
class Car {
private:
    Engine e;
    // ...
};
```

## 2. 오버라이딩(Overriding)

- **정의**: 파생 클래스에서 기반 클래스의 메서드를 재정의하는 것
- **목적**: 같은 이름의 함수지만 파생 클래스에서 다른 동작을 구현
- **예시**:
```cpp
class Base {
public:
    void what() { std::cout << "Base Class" << std::endl; }
};

class Derived : public Base {
public:
    void what() { std::cout << "Derived Class" << std::endl; }  // 오버라이딩
};
```

## 3. 가상 함수(Virtual Function)와 virtual 키워드

- **정의**: 파생 클래스에서 재정의할 것으로 기대되는 기반 클래스의 메서드
- **구현 방법**: 함수 선언 앞에 `virtual` 키워드 사용
```cpp
class Base {
public:
    virtual void what() { std::cout << "Base Class" << std::endl; }
};
```

- **동작 원리**:
  - 가상 함수 테이블(vtable)을 통해 구현
  - 실행 시간(런타임)에 어떤 함수를 호출할지 결정 (동적 바인딩)
  - 객체의 실제 타입에 따라 적절한 함수가 호출됨

### override 키워드 (C++11)
- **용도**: 파생 클래스의 함수가 기반 클래스의 가상 함수를 오버라이드함을 명시적으로 표시
- **이점**: 실수로 오버라이드하지 않는 경우를 컴파일 시간에 감지 가능
```cpp
class Derived : public Base {
public:
    void what() override { std::cout << "Derived Class" << std::endl; }
};
```

## 4. 다형성(Polymorphism)

- **정의**: 동일한 인터페이스로 다양한 타입의 객체를 다룰 수 있는 능력
- **구현 방법**: 가상 함수와 포인터/참조를 통한 동적 바인딩
- **예시**:
```cpp
void printInfo(Employee* emp) {
    emp->print_info();  // Employee 또는 Manager의 print_info가 호출됨
}

// 사용 예
Employee* emp1 = new Employee(...);
Employee* emp2 = new Manager(...);  // 업캐스팅

printInfo(emp1);  // Employee::print_info() 호출
printInfo(emp2);  // Manager::print_info() 호출
```

- **다형성의 이점**:
  - 코드 재사용성 증가
  - 확장성 향상
  - 유지보수 용이성
  - 인터페이스와 구현의 분리

## 5. 캐스팅(Casting)

### 업캐스팅(Upcasting)
- **정의**: 파생 클래스의 포인터/참조를 기반 클래스의 포인터/참조로 변환
- **특징**: 암시적 변환 가능, 안전함
```cpp
Manager* m = new Manager();
Employee* e = m;  // 업캐스팅: 암시적 변환
```

### 다운캐스팅(Downcasting)
- **정의**: 기반 클래스의 포인터/참조를 파생 클래스의 포인터/참조로 변환
- **특징**: 명시적 변환 필요, 안전하지 않을 수 있음
```cpp
Employee* e = new Manager();
Manager* m = static_cast<Manager*>(e);  // 다운캐스팅: 명시적 변환 필요
```

### dynamic_cast
- **용도**: 런타임에 안전한 다운캐스팅
- **특징**: RTTI(Run-Time Type Information)를 사용, 실패 시 nullptr 반환(포인터) 또는 예외 발생(참조)
- **조건**: 클래스에 가상 함수가 최소 하나 이상 있어야 함(다형적 클래스)
```cpp
Employee* e = new Manager();
Manager* m = dynamic_cast<Manager*>(e);  // 성공
Employee* e2 = new Employee();
Manager* m2 = dynamic_cast<Manager*>(e2);  // 실패: nullptr 반환
```

## 6. 가상 소멸자(Virtual Destructor)

- **필요성**: 기반 클래스 포인터로 파생 클래스 객체를 삭제할 때 파생 클래스의 소멸자가 호출되도록 함
- **문제 상황**: 
```cpp
Employee* e = new Manager();
delete e;  // 가상 소멸자가 없으면 Manager의 소멸자가 호출되지 않음
```
- **해결책**: 기반 클래스의 소멸자를 가상 함수로 선언
```cpp
class Employee {
public:
    virtual ~Employee() { /* 정리 작업 */ }
};
```

## 7. 순수 가상 함수와 추상 클래스

### 순수 가상 함수(Pure Virtual Function)
- **정의**: 구현이 없고 파생 클래스에서 반드시 오버라이드해야 하는 함수
- **선언 방법**: `virtual 반환타입 함수이름() = 0;`
```cpp
class Shape {
public:
    virtual double area() = 0;  // 순수 가상 함수
};
```

### 추상 클래스(Abstract Class)
- **정의**: 하나 이상의 순수 가상 함수를 포함하는 클래스
- **특징**: 
  - 객체를 직접 생성할 수 없음
  - 파생 클래스의 기본 인터페이스 역할
  - 모든 순수 가상 함수를 오버라이드하지 않으면 파생 클래스도 추상 클래스가 됨
```cpp
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() override { return 3.14 * radius * radius; }
};
```

## 8. 다중 상속과 문제점

### 다중 상속(Multiple Inheritance)
- **정의**: 한 클래스가 둘 이상의 기반 클래스를 상속받는 것
```cpp
class A { /* ... */ };
class B { /* ... */ };
class C : public A, public B { /* ... */ };
```

### 다이아몬드 문제(Diamond Problem)
- **문제**: 동일한 기반 클래스가 여러 경로로 상속될 때 발생
```
    A
   / \
  B   C
   \ /
    D
```
- **문제점**: D에서 A의 멤버를 참조할 때 모호성 발생
- **해결책**: 가상 상속(virtual inheritance) 사용
```cpp
class B : virtual public A { /* ... */ };
class C : virtual public A { /* ... */ };
class D : public B, public C { /* ... */ };
```

## 9. 면접에서 자주 묻는 질문

### Q1: 가상 함수의 작동 원리를 설명해보세요.
**A**: 가상 함수는 vtable(가상 함수 테이블)과 vptr(가상 함수 테이블 포인터)을 통해 구현됩니다. 클래스에 가상 함수가 있으면 컴파일러는 해당 클래스에 대한 vtable을 생성하고, 각 객체에는 이 vtable을 가리키는 vptr이 추가됩니다. 함수 호출 시 vptr을 통해 vtable에 접근하여 적절한 함수를 찾아 호출합니다. 이런 메커니즘을 통해 런타임에 객체의 실제 타입에 따라 적절한 함수가 호출되는 동적 바인딩이 가능해집니다.

### Q2: virtual 키워드를 사용하지 않으면 어떤 문제가 발생할 수 있나요?
**A**: virtual 키워드를 사용하지 않으면 정적 바인딩이 발생합니다. 이 경우 포인터나 참조의 컴파일 타임 타입에 따라 함수가 결정되어, 포인터가 실제로 가리키는 객체의 타입과 무관하게 기반 클래스의 함수가 호출됩니다. 이로 인해 다형성이 제대로 작동하지 않고, 파생 클래스에서 오버라이드한 함수가 호출되지 않아 예상치 못한 동작이 발생할 수 있습니다.

### Q3: 소멸자를 가상으로 선언해야 하는 이유는 무엇인가요?
**A**: 기반 클래스 포인터로 파생 클래스 객체를 삭제할 때, 소멸자가 가상이 아니면 기반 클래스의 소멸자만 호출됩니다. 이로 인해 파생 클래스의 자원이 제대로 해제되지 않아 메모리 누수가 발생할 수 있습니다. 소멸자를 가상으로 선언하면 객체의 실제 타입에 맞는 소멸자가 호출되어 모든 자원이 올바르게 해제됩니다.

### Q4: override와 overload의 차이점을 설명해보세요.
**A**: 
- **오버라이드(Override)**: 파생 클래스에서 기반 클래스의 가상 함수를 재정의하는 것입니다. 함수 시그니처(이름, 매개변수 타입, 반환 타입)가 정확히 일치해야 합니다.
- **오버로드(Overload)**: 같은 클래스 내에서 이름은 같지만 매개변수 목록이 다른 여러 함수를 정의하는 것입니다.

### Q5: dynamic_cast와 static_cast의 차이점을 설명해보세요.
**A**:
- **dynamic_cast**: 런타임에 타입 체크를 수행하며, 안전한 다운캐스팅을 위해 사용됩니다. 실패 시 포인터의 경우 nullptr, 참조의 경우 std::bad_cast 예외를 반환합니다. 다형적 클래스(가상 함수가 있는 클래스)에서만 사용 가능합니다.
- **static_cast**: 컴파일 타임에 수행되며, 암시적 변환이 가능한 타입 간 변환을 명시적으로 지시합니다. 런타임 타입 체크를 수행하지 않아 dynamic_cast보다 빠르지만, 안전성이 떨어집니다.

### Q6: 추상 클래스와 인터페이스의 차이점은 무엇인가요?
**A**: C++에서는 Java나 C#처럼 엄밀한 `interface` 키워드는 없지만, 개념적으로 인터페이스와 추상 클래스를 구현할 수 있습니다.

**인터페이스**:
- C++에서는 모든 멤버 함수가 순수 가상 함수이고 데이터 멤버가 없는 추상 클래스로 구현됩니다.
- 오직 메서드의 시그니처만 정의하고 구현은 포함하지 않습니다.
- "무엇을 할 수 있는가"를 정의합니다 (능력/기능 중심).
- 예시:
```cpp
class Drawable {
public:
    virtual void draw() = 0;
    virtual ~Drawable() = default;  // 가상 소멸자
};
```

**추상 클래스**:
- 하나 이상의 순수 가상 함수를 포함하는 클래스입니다.
- 일부 메서드는 구현을 포함할 수 있으며, 데이터 멤버를 가질 수 있습니다.
- "무엇인가"를 정의합니다 (정체성 중심).
- 예시:
```cpp
class Shape {
protected:
    int x, y;  // 데이터 멤버

public:
    Shape(int x, int y) : x(x), y(y) {}
    
    // 일부 구현된 메서드
    void moveTo(int newX, int newY) {
        x = newX;
        y = newY;
    }
    
    // 순수 가상 함수
    virtual double area() = 0;
    virtual void draw() = 0;
    
    virtual ~Shape() = default;
};
```

**주요 차이점**:
1. **구현 여부**: 인터페이스는 구현이 없지만, 추상 클래스는 일부 메서드에 구현이 있을 수 있습니다.
2. **데이터 멤버**: 인터페이스는 데이터 멤버를 가지지 않지만, 추상 클래스는 가질 수 있습니다.
3. **목적**: 인터페이스는 클래스에 특정 기능을 추가하는 것이 목적이고, 추상 클래스는 관련 클래스들의 공통 기반을 제공하는 것이 목적입니다.
4. **다중 상속**: C++에서는 다중 상속이 가능하므로 여러 인터페이스를 구현할 수 있습니다. 이는 "다중 인터페이스 구현"의 장점을 제공합니다.

**사용 시기**:
- **인터페이스**: 관련 없는 클래스들이 공통 기능을 구현해야 할 때 사용합니다 (예: `Printable`, `Serializable`).
- **추상 클래스**: 관련된 클래스들이 공통 기능과 속성을 공유해야 할 때 사용합니다 (예: `Shape`는 `Circle`, `Rectangle`의 공통 기반).

### Q7: C++에서 다중 상속의 문제점과 해결 방법을 설명해보세요.
**A**: 다중 상속의 주요 문제점은 다이아몬드 문제입니다. 이는 두 클래스가 같은 기반 클래스를 상속받고, 또 다른 클래스가 이 두 클래스를 상속받을 때 발생합니다. 이로 인해 기반 클래스의 멤버가 중복되어 모호성이 발생합니다. 해결책으로는 가상 상속(virtual inheritance)을 사용하여 기반 클래스의 인스턴스가 단 하나만 존재하도록 할 수 있습니다.

### Q8: 다형성의 장점과 단점을 설명해보세요.
**A**:
- **장점**:
  - 코드 재사용성 증가
  - 확장성 향상
  - 인터페이스와 구현의 분리
  - 유지보수 용이성
  
- **단점**:
  - 가상 함수 호출의 오버헤드로 인한 성능 저하
  - vtable과 vptr로 인한 메모리 사용량 증가
  - 디버깅의 복잡성 증가
  - 설계의 복잡성 증가

### Q9: C++의 RTTI(Run-Time Type Information)에 대해 설명해보세요.
**A**: RTTI는 프로그램 실행 중에 객체의 타입을 확인할 수 있는 C++의 기능입니다. 주요 구성 요소는 다음과 같습니다:
- **dynamic_cast**: 안전한 다운캐스팅을 위해 사용
- **typeid 연산자**: 객체의 실제 타입 정보를 반환
- **std::type_info 클래스**: 타입 정보를 저장하는 클래스

RTTI는 가상 함수를 가진 클래스에서만 객체의 실제 타입을 정확히 판별할 수 있습니다.

### Q10: final 키워드(C++11)의 용도를 설명해보세요.
**A**: final 키워드는 두 가지 용도로 사용됩니다:
1. **클래스에 사용**: 해당 클래스가 더 이상 상속될 수 없음을 명시
   ```cpp
   class Base final { /* ... */ };
   ```
2. **가상 함수에 사용**: 파생 클래스에서 해당 함수를 오버라이드할 수 없음을 명시
   ```cpp
   virtual void func() final { /* ... */ };
   ```
이를 통해 의도하지 않은 상속이나 오버라이딩을 방지하여 설계의 안정성을 높일 수 있습니다.

# C++ 상속과 가상 함수의 심화 개념

## 1. 가상 소멸자(Virtual Destructor)

### 기본 개념
- 소멸자를 가상 함수로 선언하여 상속 계층에서 메모리 누수를 방지
- 기반 클래스 포인터로 파생 클래스 객체를 삭제할 때 필수적

### 작동 원리
```cpp
class Parent {
public:
    Parent() { std::cout << "Parent 생성자 호출" << std::endl; }
    virtual ~Parent() { std::cout << "Parent 소멸자 호출" << std::endl; }
};

class Child : public Parent {
public:
    Child() { std::cout << "Child 생성자 호출" << std::endl; }
    ~Child() { std::cout << "Child 소멸자 호출" << std::endl; }
};

int main() {
    Parent* p = new Child();
    delete p;  // Child와 Parent 소멸자 모두 호출
}
```

### 소멸자 호출 순서
- 생성자: 기반 클래스 → 파생 클래스 (기반 구조를 먼저 생성 후 세부 사항 생성)
- 소멸자: 파생 클래스 → 기반 클래스 (내부부터 정리 후 외부 구조 정리)

### 주의사항
- 상속될 가능성이 있는 클래스는 항상 소멸자를 가상으로 선언해야 함
- 메모리 누수(memory leak)를 방지하고 자원을 올바르게 해제하기 위해 필수적

## 2. 가상 함수 작동 원리

### 가상 함수 테이블(vtable)
- 각 클래스마다 하나씩 생성되는 함수 포인터 배열
- 클래스에 정의된 모든 가상 함수의 포인터를 포함
- 컴파일 시간에 생성됨

### 가상 함수 포인터(vptr)
- 가상 함수가 있는 클래스의 객체마다 내부적으로 포함된 숨겨진 포인터
- 해당 클래스의 vtable을 가리킴
- 객체 생성 시 초기화됨

### 동적 바인딩 과정
1. 객체의 vptr을 통해 해당 클래스의 vtable에 접근
2. vtable에서 호출하려는 함수의 실제 주소를 찾음
3. 찾은 주소의 함수를 호출

### 예시
```cpp
class Parent {
public:
    virtual void func() { std::cout << "Parent::func" << std::endl; }
};

class Child : public Parent {
public:
    void func() override { std::cout << "Child::func" << std::endl; }
};

// 호출 시
Parent* p = new Child();
p->func();  // "Child::func" 출력
```

### 성능 영향
- 가상 함수 호출은 일반 함수 호출보다 약간 느림 (추가 메모리 액세스 필요)
- 각 객체에 vptr로 인한 메모리 오버헤드 발생 (포인터 크기: 32비트에서 4바이트, 64비트에서 8바이트)
- 현대 CPU에서는 영향이 미미하지만, 성능이 중요한 경우 고려 필요

## 3. 순수 가상 함수와 추상 클래스

### 순수 가상 함수(Pure Virtual Function)
- 구현부가 없고 `= 0`으로 선언된 가상 함수
- 파생 클래스에서 반드시 구현해야 함
- 함수 선언 문법: `virtual 반환타입 함수이름(매개변수) = 0;`

```cpp
virtual void speak() = 0;  // 순수 가상 함수
```

### 추상 클래스(Abstract Class)
- 하나 이상의 순수 가상 함수를 포함하는 클래스
- 직접 인스턴스화 할 수 없음 (객체 생성 불가)
- 포인터나 참조는 생성 가능
- 모든 순수 가상 함수를 오버라이드해야 인스턴스화 가능

```cpp
class Animal {
public:
    virtual void speak() = 0;  // 순수 가상 함수
    virtual ~Animal() {}       // 가상 소멸자
};

class Dog : public Animal {
public:
    void speak() override { std::cout << "왈왈" << std::endl; }
};
```

### 추상 클래스의 목적
- 공통 인터페이스 정의
- 파생 클래스에서 구현해야 할 기능 명시
- '설계도' 역할 - 기본 프레임워크 제공

## 4. 인터페이스 설계 (C++에서의 구현)

### 인터페이스 개념
- C++에는 명시적인 인터페이스 키워드가 없음
- 모든 함수가 순수 가상 함수인 추상 클래스로 구현
- 데이터 멤버가 없고 구현 코드가 없는 클래스

### 인터페이스 예시
```cpp
class Printable {
public:
    virtual void print() = 0;
    virtual ~Printable() = default;  // 가상 소멸자
};

class Document : public Printable {
public:
    void print() override { std::cout << "문서 인쇄" << std::endl; }
};
```

### 인터페이스 vs 추상 클래스
- **인터페이스**: 전체가 순수 가상 함수, 구현 없음, "할 수 있는 것" 정의
- **추상 클래스**: 일부 구현 포함 가능, 데이터 멤버 가질 수 있음, "무엇인지" 정의

## 5. 다중 상속(Multiple Inheritance)

### 기본 개념
- 한 클래스가 두 개 이상의 클래스를 동시에 상속
- 모든 기반 클래스의 멤버를 모두 포함

```cpp
class A { /* ... */ };
class B { /* ... */ };
class C : public A, public B { /* ... */ };
```

### 생성자 호출 순서
- 상속 선언 순서대로 기반 클래스 생성자 호출
- `class C : public A, public B` → A 생성자 → B 생성자 → C 생성자
- `class C : public B, public A` → B 생성자 → A 생성자 → C 생성자

### 다중 상속의 문제점

#### 1. 이름 충돌
- 동일한 이름의 멤버가 여러 기반 클래스에 존재할 경우 모호성 발생
- 범위 지정 연산자(::)로 명시적 지정 필요

```cpp
class A { public: int x; };
class B { public: int x; };
class C : public A, public B {
public:
    void func() {
        // A::x와 B::x 중 어느 것을 의미하는지 모호함
        // x = 10;  // 컴파일 오류
        
        // 명시적 지정 필요
        A::x = 10;
        B::x = 20;
    }
};
```

#### 2. 다이아몬드 문제(Diamond Problem)
- 같은 기반 클래스가 여러 경로로 상속되는 경우
- 중복 상속으로 인한 멤버 중복과 모호성 발생

```
    A
   / \
  B   C
   \ /
    D
```

- D에서 A의 멤버에 접근할 때 B를 통할지 C를 통할지 모호함
- A의 멤버가 D에 두 번 포함됨

### 가상 상속을 통한 다이아몬드 문제 해결

- `virtual` 키워드를 사용하여 중간 클래스가 기반 클래스를 상속
- 기반 클래스의 인스턴스가 최종 파생 클래스에 하나만 존재하도록 보장

```cpp
class A { public: int data; };
class B : virtual public A { /* ... */ };
class C : virtual public A { /* ... */ };
class D : public B, public C { /* ... */ };
```

- 가상 상속 시 최종 파생 클래스(D)는 가상 기반 클래스(A)의 생성자를 직접 호출해야 함

## 6. 면접에서 자주 묻는 질문

### Q1: 가상 소멸자가 필요한 이유를 설명해보세요.
**A**: 상속 관계에서 기반 클래스의 포인터로 파생 클래스 객체를 삭제할 때, 기반 클래스의 소멸자가 가상이 아니면 파생 클래스의 소멸자가 호출되지 않습니다. 이로 인해 파생 클래스에서 할당한 자원이 해제되지 않아 메모리 누수가 발생할 수 있습니다. 가상 소멸자를 사용하면 객체의 실제 타입에 맞는 소멸자가 호출되어 모든 자원이 올바르게 해제됩니다.

### Q2: 가상 함수의 작동 원리를 설명해보세요.
**A**: 가상 함수는 vtable(가상 함수 테이블)과 vptr(가상 함수 테이블 포인터)를 통해 구현됩니다. 클래스에 가상 함수가 있으면 해당 클래스에 대한 vtable이 생성되고, 이 vtable에는 모든 가상 함수의 실제 주소가 저장됩니다. 각 객체는 vptr을 가지며 이를 통해 자신의 클래스 vtable에 접근합니다. 가상 함수 호출 시 컴파일러는 객체의 vptr을 통해 vtable에 접근하고, 해당 함수의 실제 주소를 찾아 호출합니다. 이를 통해 객체의 실제 타입에 맞는 함수가 동적으로 결정됩니다.

### Q3: 순수 가상 함수와 일반 가상 함수의 차이점은 무엇인가요?
**A**: 
- **일반 가상 함수**는 구현을 가지며 파생 클래스에서 오버라이드할 수 있는 함수입니다. 오버라이드하지 않으면 기반 클래스의 구현이 사용됩니다.
- **순수 가상 함수**는 `= 0`으로 선언되고 구현이 없습니다. 파생 클래스에서 반드시 오버라이드해야 하며, 순수 가상 함수가 있는 클래스는 추상 클래스가 되어 직접 인스턴스화할 수 없습니다.

### Q4: 가상 상속이 필요한 상황을 설명해보세요.
**A**: 가상 상속은 다이아몬드 상속 문제를 해결하기 위해 필요합니다. 다이아몬드 상속은 클래스 A를 B와 C가 상속받고, D가 B와 C를 모두 상속받는 구조입니다. 이 경우 A의 멤버가 D에 두 번 포함되어 모호성이 발생합니다. B와 C가 A를 가상 상속하면 A의 멤버가 D에 한 번만 포함되어 모호성이 해결됩니다. 가상 상속은 복잡한 상속 계층에서 같은 기반 클래스의 중복을 방지할 때 사용합니다.

### Q5: 다중 상속의 장단점을 설명해보세요.
**A**:
- **장점**:
  - 여러 클래스의 기능을 한 클래스에 결합 가능
  - 코드 재사용성 증가
  - 다양한 인터페이스 구현 가능
  - 복잡한 상속 관계 모델링 가능

- **단점**:
  - 다이아몬드 문제와 같은 복잡성 발생
  - 이름 충돌 및 모호성 문제
  - 유지보수 어려움
  - 컴파일 시간 증가 및 실행 시간 오버헤드

### Q6: 추상 클래스와 인터페이스의 차이점을 C++의 관점에서 설명해보세요.
**A**: C++에는 Java나 C#과 같은 별도의 인터페이스 키워드가 없습니다. 대신 추상 클래스의 특별한 형태로 인터페이스를 구현합니다.
- **추상 클래스**: 하나 이상의 순수 가상 함수를 포함하는 클래스로, 일부 메서드는 구현을 가질 수 있고 데이터 멤버를 포함할 수 있습니다.
- **인터페이스(C++에서)**: 모든 멤버 함수가 순수 가상 함수이고, 데이터 멤버가 없는 추상 클래스입니다. 구현 없이 오직 메서드의 시그니처만 정의합니다.

추상 클래스는 "무엇인가"를 정의하는 반면, 인터페이스는 "무엇을 할 수 있는가"를 정의합니다.

### Q7: C++에서 가상 함수를 사용할 때의 오버헤드는 무엇인가요?
**A**: 가상 함수 사용 시 발생하는 오버헤드는 다음과 같습니다:
- **메모리 오버헤드**: 각 객체에 vptr(가상 함수 테이블 포인터)가 추가되어 객체 크기가 증가합니다(32비트 시스템에서 4바이트, 64비트 시스템에서 8바이트).
- **성능 오버헤드**: 가상 함수 호출은 vtable을 통한 간접 호출이므로 일반 함수 호출보다 약간 느립니다. 이는 추가적인 메모리 액세스와 간접 참조가 필요하기 때문입니다.
- **컴파일 최적화 제한**: 가상 함수는 인라인화(inlining)가 어렵기 때문에 컴파일러의 최적화 기회가 줄어듭니다.

하지만 현대 CPU와 컴파일러에서는 이러한 오버헤드가 대부분의 경우 무시할 만큼 작습니다.

### Q8: 레퍼런스를 사용한 다형성과 포인터를 사용한 다형성의 차이점은 무엇인가요?
**A**: 레퍼런스와 포인터 모두 다형성을 구현하는 데 사용할 수 있으며, 다음과 같은 차이점이 있습니다:
- **초기화**: 레퍼런스는 선언 시 반드시 초기화해야 하고 null이 될 수 없습니다. 포인터는 선언 후 초기화할 수 있고 null이 될 수 있습니다.
- **재할당**: 레퍼런스는 한 번 초기화하면 다른 객체를 참조하도록 변경할 수 없습니다. 포인터는 다른 객체를 가리키도록 변경할 수 있습니다.
- **문법**: 레퍼런스는 일반 객체처럼 `.` 연산자로 멤버에 접근합니다. 포인터는 `->` 연산자를 사용합니다.
- **안전성**: 레퍼런스는 항상 유효한 객체를 참조해야 하므로 null 체크가 필요 없어 더 안전합니다. 포인터는 null이 될 수 있어 사용 전 확인이 필요합니다.

다형성 동작 자체는 두 경우 모두 동일합니다.

### Q9: final 키워드(C++11)의 용도와 사용하는 이유를 설명해보세요.
**A**: C++11에서 도입된 final 키워드는 두 가지 용도로 사용됩니다:
1. **클래스에 사용**: 해당 클래스가 더 이상 상속될 수 없음을 지정합니다.
   ```cpp
   class Base final { /* ... */ };
   ```
2. **가상 함수에 사용**: 파생 클래스에서 해당 함수를 오버라이드할 수 없음을 지정합니다.
   ```cpp
   virtual void func() final { /* ... */ };
   ```

final을 사용하는 이유:
- 설계 의도를 명확히 표현 (이 클래스/함수는 더 이상 확장/변경되지 않아야 함)
- 잠재적인 오버라이드 오류 방지
- 컴파일러 최적화 가능성 증가 (가상 함수 테이블 최적화 가능)
- 보안 강화 (중요한 기능이 하위 클래스에서 변경되는 것 방지)

### Q10: 다중 상속을 사용해야 하는 상황과 피해야 하는 상황을 설명해보세요.
**A**: 

**사용해야 하는 상황**:
- 여러 독립적인 인터페이스를 구현해야 할 때 (예: `class FileWriter : public Writable, public Closable`)
- 기능이 명확히 분리된 여러 기반 클래스의 기능이 모두 필요할 때
- 다양한 타입으로 객체를 다룰 필요가 있을 때 (여러 is-a 관계가 동시에 필요한 경우)

**피해야 하는 상황**:
- 다이아몬드 문제가 발생할 수 있고 가상 상속으로 해결하기 어려운 경우
- 상속 계층이 너무 복잡해질 때
- 단일 상속과 컴포지션(composition)으로 더 간단하게 해결할 수 있는 경우
- 이름 충돌이 많이 발생하는 경우

일반적으로 "다중 상속보다 컴포지션을 선호하라"는 원칙을 따르는 것이 좋습니다. 다중 상속은 복잡성을 증가시키므로 반드시 필요한 경우에만 사용해야 합니다.
