# C++의 기본 문법 구조와 변수 정의

## 변수 정의
- C++은 C와 동일한 기본 변수 정의 방식 사용
- 변수명 규칙도 동일 (알파벳, _, 숫자 사용 가능)
- 첫 글자에 숫자 사용 불가

## 변수 이름 작성 규칙 (Google 스타일 가이드)
1. 명확한 의미 전달
   ```cpp
   int number_of_people;  // 좋은 예시
   double interest_rate;  // 좋은 예시
   ```
2. 명명 규칙
   - snake_case: `number_of_people` (변수에 권장)
   - CamelCase: `NumberOfPeople` (함수에 권장)
   - 한 프로젝트 내에서 일관된 스타일 유지 중요

## 제어문 구조
### for 루프
```cpp
for (int i = 0; i < 10; i++) {
    std::cout << i << std::endl;
}
```

### while 루프
```cpp
while (condition) {
    // 코드
}
```

### if-else 문
```cpp
if (condition) {
    // 코드
} else {
    // 코드
}
```

### switch 문
```cpp
switch (variable) {
    case 1:
        // 코드
        break;
    default:
        // 코드
        break;
}
```

## C++의 주요 차이점
1. 변수 선언 위치
   - C: 함수 시작 부분에서만 가능
   - C++: 코드 어디에서나 가능

2. 입출력 방식
   ```cpp
   std::cout << "출력" << std::endl;  // 출력
   std::cin >> variable;              // 입력
   ```
   - 형식 지정자(%d, %c 등) 불필요
   - 입력 시 & 연산자 불필요

## 결론
- C++은 C의 기본 문법을 대부분 그대로 계승
- 변수 선언과 입출력에서 더 유연하고 편리한 기능 제공
- 코드 스타일의 일관성이 중요

# C++ 레퍼런스(참조자) 개념과 활용

## 레퍼런스의 기본 개념
- 다른 변수나 상수를 가리키는 별명(alias)
- 기본 문법: `Type& reference_name = variable;`
```cpp
int a = 3;
int& another_a = a;  // another_a는 a의 별명
```

## 레퍼런스와 포인터의 차이점
1. 초기화 필수
   - 레퍼런스는 선언 시 반드시 초기화해야 함
   - 포인터는 선언만 가능

2. 재참조 불가
   - 레퍼런스는 한번 지정된 변수만 참조 가능
   - 포인터는 가리키는 대상 변경 가능

3. 메모리 상 존재
   - 레퍼런스는 경우에 따라 메모리 공간을 차지하지 않을 수 있음
   - 포인터는 항상 메모리 공간 차지

## 함수에서의 레퍼런스 활용
```cpp
void changeVal(int& num) {  // 참조자로 인자 전달
    num = 3;
}

int main() {
    int number = 5;
    changeVal(number);  // & 없이 호출 가능
}
```

## 레퍼런스의 제약사항
1. 레퍼런스의 배열 생성 불가
2. 레퍼런스의 레퍼런스 생성 불가
3. NULL 레퍼런스 불가능

## 상수와 레퍼런스
```cpp
// 일반 참조자로는 상수 참조 불가
int& ref = 4;  // 컴파일 에러

// 상수 참조자로는 가능
const int& ref = 4;  // 정상 작동
```

## 함수의 레퍼런스 리턴
- 지역 변수의 레퍼런스를 리턴하면 위험(dangling reference)
- 외부 변수의 레퍼런스는 안전하게 리턴 가능
- 함수 리턴값을 상수 레퍼런스로 받을 수 있음

```cpp
int& function(int& a) {  // 안전한 레퍼런스 리턴
    return a;
}

const int& c = getValue();  // 상수 레퍼런스로 리턴값 받기
```

## 주의사항
- 댕글링 레퍼런스(dangling reference) 조심
- 지역 변수의 레퍼런스를 리턴하지 않기
- 레퍼런스 사용 시 생명주기 고려

# C++의 new와 delete, 그리고 객체지향 프로그래밍 소개

## 메모리 관리의 중요성
- C++에서는 힙(heap) 메모리를 통해 실행 시간에 자유롭게 메모리를 할당하고 해제할 수 있음
- 스택(stack)과 달리 힙은 사용자가 직접 제어해야 하므로 더 큰 책임이 따름

## new와 delete 연산자
- `new`: 메모리 할당 (C의 malloc에 해당)
- `delete`: 메모리 해제 (C의 free에 해당)
- 기본 사용법:
  ```cpp
  int* p = new int;  // 메모리 할당
  *p = 10;           // 값 할당
  delete p;          // 메모리 해제
  ```

## 배열 할당
- `new[]`와 `delete[]` 사용
- 예시:
  ```cpp
  int* list = new int[size];    // 배열 할당
  // 배열 사용
  delete[] list;                // 배열 해제
  ```

## C++의 새로운 특징
- 변수를 코드 어디서나 선언 가능
- 변수는 선언된 블록({}) 범위 내에서만 유효
- 컴파일러는 가장 가까운 범위의 변수를 우선 참조

## 객체지향 프로그래밍으로의 전환
- 구조체에 함수를 포함시켜 데이터와 기능을 통합할 수 있음
- 상속을 통해 코드 중복을 줄이고 확장성을 높일 수 있음
- 예시: Animal 구조체를 기반으로 Bird, Fish 등으로 확장 가능
  - 기존 방식: 각각의 구조체를 별도로 정의하고 관리해야 함
  - 객체지향 방식: 기본 구조를 상속받아 필요한 기능만 추가 가능

## 결론
- C++은 C의 기능을 확장하여 더 효율적인 프로그래밍을 가능하게 함
- 객체지향 프로그래밍을 통해 코드의 재사용성과 유지보수성을 향상시킬 수 있음
