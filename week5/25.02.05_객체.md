# 객체 지향 프로그래밍과 C++의 클래스

## 객체의 필요성
- C 언어의 구조체와 함수 기반 프로그래밍의 한계
- 프로그램의 규모가 커지면서 새로운 패러다임 필요
- 데이터와 기능을 하나의 단위로 묶는 개념 필요

## 객체의 정의와 특징
1. 객체의 구성
   - 변수(데이터)와 함수(메소드)의 결합
   - 자신의 상태를 나타내는 변수들
   - 자신이 수행할 수 있는 기능(함수들)

2. 캡슐화(Encapsulation)
   - 데이터를 외부로부터 보호
   - 함수를 통해서만 데이터 접근 가능
   - 내부 구현을 숨기고 인터페이스만 제공

## C++의 클래스
```cpp
class Animal {
private:
    int food;
    int weight;

public:
    void set_animal(int _food, int _weight);
    void increase_food(int inc);
    void view_stat();
};
```

### 주요 개념
1. 접근 지시자
   - private: 클래스 내부에서만 접근 가능
   - public: 외부에서도 접근 가능
   - 기본값은 private

2. 멤버 구성
   - 멤버 변수(Member Variables)
   - 멤버 함수(Member Functions)

3. 인스턴스
   - 클래스를 통해 생성된 실제 객체
   - 멤버 변수와 함수는 인스턴스를 통해 사용

## 장점
- 코드의 재사용성 향상
- 데이터 보호 및 은닉
- 사용자는 내부 구현을 알 필요 없음
- 유지보수가 용이

## 용어 정리
- 클래스: 객체의 설계도
- 인스턴스: 클래스를 통해 생성된 실제 객체
- 멤버 변수: 클래스 내의 변수
- 멤버 함수: 클래스 내의 함수
- 인스턴스 변수: 생성된 객체의 변수
- 인스턴스 메소드: 생성된 객체의 함수

# C++ 함수 오버로딩과 생성자

## 함수 오버로딩(Function Overloading)
- 같은 이름의 함수를 여러 개 정의할 수 있는 기능
- 매개변수의 타입이나 개수가 다르면 같은 이름 사용 가능
```cpp
void print(int x);
void print(char x);
void print(double x);
```

### 오버로딩 함수 선택 과정
1. 정확히 일치하는 타입 찾기
2. 기본 타입 변환 시도 (char→int, float→double 등)
3. 포괄적 형변환 시도 (numeric→numeric)
4. 사용자 정의 변환 시도

## 생성자(Constructor)
- 객체 생성 시 자동으로 호출되는 특별한 함수
- 클래스 이름과 동일한 이름을 가짐
- 리턴 타입이 없음

### 생성자 종류
1. 기본 생성자
```cpp
Date() {
    year_ = 2012;
    month_ = 7;
    day_ = 12;
}
```

2. 매개변수가 있는 생성자
```cpp
Date(int year, int month, int day) {
    year_ = year;
    month_ = month;
    day_ = day;
}
```

### 디폴트 생성자
- 매개변수가 없는 생성자
- 클래스에 생성자가 하나도 없으면 컴파일러가 자동 생성
- C++11부터는 `= default`로 명시적 선언 가능
```cpp
Class Test {
public:
    Test() = default;
};
```

### 생성자 호출 방법
```cpp
Date day1;                    // 기본 생성자
Date day2(2023, 2, 5);       // 암시적 호출
Date day3 = Date(2023, 2, 5); // 명시적 호출
```

## 주의사항
- 다른 생성자를 정의하면 컴파일러는 기본 생성자를 자동 생성하지 않음
- 기본 생성자 호출 시 `Date day()` 형태는 함수 선언으로 해석됨
- 생성자도 오버로딩이 가능함

# C++ 복사 생성자와 소멸자

## 복사 생성자(Copy Constructor)
- 객체를 복사할 때 호출되는 특별한 생성자
- 기본 형태: `ClassName(const ClassName& other)`
- 사용 예:
```cpp
ClassName obj2(obj1);      // 직접 호출
ClassName obj2 = obj1;     // 복사 초기화
```

### 깊은 복사 vs 얕은 복사
1. 얕은 복사(Shallow Copy)
   - 포인터 값만 복사
   - 디폴트 복사 생성자가 수행
   - 메모리 관련 문제 발생 가능

2. 깊은 복사(Deep Copy)
   - 포인터가 가리키는 데이터까지 새로 할당하여 복사
   - 동적 할당된 멤버가 있을 경우 필요
   - 사용자 정의 필요

## 소멸자(Destructor)
- 객체가 소멸될 때 자동으로 호출되는 함수
- 클래스명 앞에 `~` 붙임
- 인자를 가질 수 없음
- 동적 할당된 메모리 해제 등에 사용

### 특징
```cpp
~ClassName() {
    // 정리 작업 수행
    if (ptr != nullptr) delete[] ptr;
}
```
- 오버로딩 불가능
- 반환값 없음
- 자동 호출

## 주의사항
1. 포인터 멤버가 있는 클래스
   - 깊은 복사 구현 필요
   - 소멸자에서 메모리 해제 필요

2. 디폴트 복사 생성자 한계
   - 동적 할당된 멤버 변수가 있을 경우 주의
   - 메모리 누수나 이중 해제 문제 발생 가능

3. 문자열 처리
   - C 스타일 문자열 대신 `std::string` 사용 권장
   - 메모리 관리 자동화로 안전성 향상

