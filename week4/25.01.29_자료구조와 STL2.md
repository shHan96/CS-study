# 자료구조

## 정렬 (Sort)

### 버블 정렬 (Bubble Sort)
인접한 두 원소를 비교하여 정렬하는 가장 기본적인 정렬 알고리즘입니다.

**특징:**
- 구현이 매우 단순하고 이해하기 쉬움
- 안정 정렬(Stable Sort)임
- 제자리 정렬(In-place Sort)로 추가 메모리가 거의 필요하지 않음

**장점:**
- 구현이 간단하여 빠르게 작성 가능
- 안정 정렬이므로 같은 값의 순서가 보장됨
- 정렬하면서 데이터의 변경 여부를 감지할 수 있음

**단점:**
- 시간 복잡도가 O(n²)로 매우 비효율적
- 데이터가 많을 경우 실용적이지 않음
- 교환 연산이 많이 발생하여 비효율적

### 병합 정렬 (Merge Sort)
분할 정복(Divide and Conquer) 알고리즘을 기반으로 하는 정렬 방식으로, 리스트를 작은 단위로 쪼개서 정렬한 후 다시 합치는 방식입니다.

**특징:**
- 안정 정렬(Stable Sort)
- 분할 정복 알고리즘의 대표적 예시
- 항상 O(n log n)의 시간 복잡도 보장

**장점:**
- 안정적인 정렬 방법
- 데이터의 분포에 영향을 덜 받음
- 연결 리스트의 정렬에 적합
- 대용량 데이터 정렬에 효과적

**단점:**
- 추가 메모리 공간 필요 (공간 복잡도 O(n))
- 레코드가 많을 경우 이동 횟수가 많아짐
- 배열의 경우 임시 배열이 필요함

**활용 분야:**
1. 대용량 데이터 정렬
2. 외부 정렬
3. 안정성이 필요한 정렬 상황

### 힙 정렬 (Heap Sort)
힙 자료구조를 이용하여 정렬하는 방법으로, 모든 노드가 힙 속성을 만족하도록 정렬합니다.

**특징:**
- 이진 힙(Binary Heap) 사용
- 불안정 정렬
- 제자리 정렬 가능

**장점:**
- 시간 복잡도가 O(n log n)으로 보장됨
- 추가 메모리가 거의 필요 없음
- 최대값/최소값을 빠르게 찾을 수 있음

**단점:**
- 불안정 정렬
- 같은 O(n log n) 알고리즘들에 비해 상수가 큼
- 캐시 지역성이 좋지 않음

**활용 분야:**
1. 우선순위 큐 구현
2. K번째 요소 찾기
3. 제한된 메모리에서의 정렬

### 퀵 정렬 (Quick Sort)
분할 정복을 사용하는 매우 빠른 정렬 알고리즘으로, 피벗을 사용하여 배열을 분할하고 정렬합니다.

**특징:**
- 불안정 정렬
- 분할 정복 알고리즘
- 평균적으로 가장 빠른 정렬 알고리즘

**장점:**
- 평균 시간 복잡도 O(n log n)으로 매우 빠름
- 추가 메모리가 거의 필요 없음
- 캐시 지역성이 좋음

**단점:**
- 최악의 경우 O(n²) 시간 복잡도
- 불안정 정렬
- 피벗 선택이 성능에 큰 영향을 미침

**활용 분야:**
1. 프로그래밍 언어의 기본 정렬 라이브러리
2. 대규모 데이터 정렬
3. 정렬 벤치마크의 기준 알고리즘

### 버킷 정렬 (Bucket Sort)
데이터를 일정한 범위를 가진 버킷으로 분류한 뒤, 각 버킷 내부에서 정렬하고 다시 합치는 방식입니다.

**특징:**
- 분산 정렬 알고리즘
- 데이터가 균등하게 분포되어 있을 때 효과적
- 정수나 실수 정렬에 적합

**장점:**
- 평균 시간 복잡도 O(n+k) (k는 버킷의 수)
- 데이터가 균등 분포일 때 매우 효율적
- 안정 정렬 가능

**단점:**
- 추가 메모리가 많이 필요
- 데이터 분포에 따라 성능 편차가 큼
- 버킷 크기 설정이 중요

**활용 분야:**
1. 균등 분포된 데이터 정렬
2. 부동 소수점 숫자 정렬
3. 특정 범위 내의 정수 정렬

### 삽입 정렬 (Insertion Sort)
배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 부분과 비교하여 자신의 위치를 찾아 삽입합니다.

**특징:**
- 실제로 사용되는 간단한 정렬 알고리즘
- 안정 정렬임
- 작은 데이터셋에서 효율적

**장점:**
- 구현이 간단함
- 이미 정렬된 데이터에 대해 매우 효율적 (O(n))
- 제자리 정렬로 메모리 효율적
- 온라인 알고리즘: 데이터가 하나씩 들어와도 정렬 가능

**단점:**
- 평균적으로 O(n²)의 시간 복잡도
- 큰 데이터셋에서는 비효율적
- 배열 크기가 클수록 이동 연산이 많아짐

## 큐 (Queue)

FIFO(First In First Out) 원칙을 따르는 선형 자료구조로, 먼저 들어온 데이터가 먼저 나가는 구조입니다.

**특징:**
- 선입선출(FIFO) 구조
- front와 rear 두 개의 포인터 사용
- 순차적인 데이터 처리에 적합

**활용 분야:**
1. 프로세스 스케줄링
2. 입출력 버퍼 관리
3. 네트워크 패킷 처리
4. 너비 우선 탐색(BFS) 구현

**장점:**
- 데이터의 순서가 보장됨
- 삽입과 삭제가 O(1)로 빠름
- 데이터의 접근이 제한적이라 안전함
- 간단하고 사용하기 쉬움

**단점:**
- 중간 데이터 접근 불가
- 데이터 검색이 어려움
- 크기가 고정된 경우 메모리 낭비 발생 가능

## 스택 (Stack)

LIFO(Last In First Out) 원칙을 따르는 선형 자료구조로, 가장 마지막에 들어온 데이터가 가장 먼저 나가는 구조입니다.

**특징:**
- 후입선출(LIFO) 구조
- 한 쪽 끝에서만 데이터 삽입/삭제 가능
- 재귀적 문제 해결에 적합

**활용 분야:**
1. 함수 호출 관리 (콜 스택)
2. 수식 계산 및 구문 분석
3. 웹 브라우저 방문 기록
4. 실행 취소 (Undo) 기능
5. 깊이 우선 탐색(DFS) 구현

**장점:**
- 구현이 매우 간단
- 데이터의 삽입/삭제가 O(1)로 빠름
- 메모리 관리가 용이
- 후위 표기법 계산에 적합

**단점:**
- 중간 데이터 접근 불가
- 데이터 검색이 어려움
- 스택 오버플로우 위험
- 데이터의 최대 개수를 미리 지정해야 하는 경우가 많음

## 연결 리스트 (Linked List)

각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조입니다.

### 단일 연결 리스트 (Singly Linked List)

**특징:**
- 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성
- 단방향으로만 이동 가능
- 마지막 노드의 포인터는 NULL을 가리킴

**장점:**
- 삽입과 삭제가 O(1)로 빠름
- 메모리를 동적으로 사용
- 크기가 가변적

**단점:**
- 역방향 순회 불가
- 특정 위치 접근에 O(n) 시간 소요
- 추가 메모리 공간 필요 (포인터)

### 이중 연결 리스트 (Doubly Linked List)

**특징:**
- 각 노드가 이전 노드와 다음 노드의 포인터를 모두 가짐
- 양방향 이동 가능
- 양끝에 더미 노드를 두어 구현하는 경우가 많음

**장점:**
- 양방향 순회 가능
- 노드 삭제가 단일 연결 리스트보다 효율적
- 이전 노드를 찾는데 O(1) 시간 소요

**단점:**
- 구현이 더 복잡함
- 메모리 사용량이 더 많음 (추가 포인터)
- 삽입/삭제 시 포인터 처리가 더 복잡

### 원형 연결 리스트 (Circular Linked List)

**특징:**
- 마지막 노드가 첫 번째 노드를 가리킴
- 단일 또는 이중 연결 리스트로 구현 가능
- 순환 구조를 가짐

**장점:**
- 순환 데이터 표현에 적합
- 리스트의 끝에서 처음으로 쉽게 이동 가능
- 메모리 효율적인 버퍼 구현 가능

**단점:**
- 구현이 약간 더 복잡
- 무한 루프 주의 필요
- 종료 조건 처리가 까다로움

**연결 리스트의 일반적인 활용 분야:**
1. 메모리가 제한적인 환경에서의 데이터 관리
2. 폴리노미얼 표현
3. 운영체제의 프로세스 관리
4. 메모리 관리 시스템
5. 음악 플레이어의 재생 목록
6. 언두/리두 기능 구현

## 트리 구조

### Red-Black Tree
레드-블랙 트리는 자가 균형 이진 탐색 트리의 한 종류로, 효율적인 검색과 수정 연산을 보장합니다.

**핵심 특징:**
1. 모든 노드는 빨간색 또는 검은색입니다.
2. 루트와 NIL(리프) 노드는 항상 검은색입니다.
3. 빨간 노드의 자식은 반드시 검은색입니다.
4. 루트에서 모든 리프까지의 경로에는 동일한 수의 검은 노드가 있습니다.

**장점:**
- 균형 잡힌 트리 구조를 유지하여 최악의 경우에도 O(log n)의 성능을 보장
- AVL 트리에 비해 삽입/삭제 시 회전 연산이 적음
- 실제 응용에서 좋은 성능을 보임

**단점:**
- 구현이 복잡함
- 색상 정보를 저장하기 위한 추가 메모리 필요
- 완벽한 균형은 아님 (AVL 트리보다 불균형할 수 있음)

**활용 사례:**
- C++ STL의 map, set 구현
- 데이터베이스 인덱싱
- 실시간 데이터 처리가 필요한 시스템

### AVL Tree
AVL 트리는 가장 처음으로 발명된 자가 균형 이진 탐색 트리입니다.

**핵심 특징:**
1. 모든 노드의 좌우 서브트리 높이 차이가 최대 1입니다.
2. 완벽한 균형을 유지합니다.

**장점:**
- 완벽한 균형으로 인한 빠른 검색 성능
- 예측 가능한 성능 (항상 일정한 균형을 유지)
- 구현이 Red-Black 트리보다 단순

**단점:**
- 엄격한 균형 조건으로 인해 삽입/삭제 시 더 많은 회전 필요
- Red-Black 트리에 비해 실제 응용에서 성능이 떨어질 수 있음

**활용 사례:**
- 빈번한 검색이 필요한 데이터베이스
- 메모리 데이터베이스
- 실시간 검색이 중요한 시스템

### B-Tree
B-트리는 다중 경로 탐색 트리로, 디스크 기반 저장 시스템에 최적화되어 있습니다.

**핵심 특징:**
1. 노드가 여러 개의 키를 가질 수 있음
2. 모든 리프가 같은 레벨에 있음
3. 노드의 키는 정렬되어 있음

**장점:**
- 디스크 I/O를 최소화
- 범위 검색에 효율적
- 높은 팬아웃(자식 수)으로 인한 낮은 트리 높이

**단점:**
- 구현이 복잡함
- 메모리 사용량이 많음
- 작은 데이터셋에는 오버헤드가 큼

**활용 사례:**
- 데이터베이스 인덱싱
- 파일 시스템
- 대용량 데이터 저장소

## 힙 (Heap)

힙은 완전 이진 트리를 기반으로 한 우선순위 큐 구현에 사용되는 자료구조입니다.

**핵심 특징:**
1. 최대 힙 또는 최소 힙으로 구성
2. 완전 이진 트리 형태
3. 부모-자식 간의 대소 관계가 일정

**장점:**
- 최대/최소값 빠른 접근 (O(1))
- 효율적인 삽입/삭제 (O(log n))
- 배열로 구현 가능하여 캐시 효율적
- 메모리 사용이 효율적

**단점:**
- 특정 값 검색이 어려움 (O(n))
- 중간 값 삭제가 어려움
- 순서 유지가 되지 않음

**활용 사례:**
- 우선순위 큐 구현
- 운영체제의 작업 스케줄링
- 다익스트라 알고리즘
- 이벤트 큐 시스템

## 그래프 (Graph)

그래프는 노드(정점)와 에지(간선)로 이루어진 자료구조로, 다양한 관계를 표현할 수 있습니다.

**표현 방식:**
1. 인접 행렬
   - 장점: 빠른 엣지 검색, 구현 간단
   - 단점: 메모리 사용량 많음 (O(V²))

2. 인접 리스트
   - 장점: 메모리 효율적 (O(V+E))
   - 단점: 엣지 검색이 느림

**주요 알고리즘별 특징:**

1. BFS (너비 우선 탐색)
   - 최단 경로 찾기에 적합
   - 레벨 단위 탐색에 유용
   - 메모리 사용량이 많음

2. DFS (깊이 우선 탐색)
   - 경로 탐색에 적합
   - 메모리 사용량이 적음
   - 재귀적 문제 해결에 유용

3. 다익스트라 알고리즘
   - 단일 출발점 최단 경로
   - 음의 가중치 처리 불가
   - 우선순위 큐로 최적화 가능

**활용 사례:**
- 소셜 네트워크
- 네비게이션 시스템
- 네트워크 라우팅
- 게임의 상태 공간 탐색

## 해시 테이블 (Hash Table)

해시 테이블은 키-값 쌍을 저장하는 자료구조로, 평균적으로 O(1)의 검색 시간을 제공합니다.

### 해시 함수의 종류와 특징

1. **Division Method (나눗셈법)**
   ```cpp
   int hash(int key, int tableSize) {
       return key % tableSize;
   }
   ```
   **특징:**
   - 구현이 간단하고 빠름
   - tableSize를 소수로 선택하는 것이 좋음
   - 연속된 키들이 같은 해시값을 가질 수 있음
   
2. **Multiplication Method (곱셈법)**
   ```cpp
   int hash(int key, int tableSize) {
       const double A = 0.6180339887; // (√5 - 1) / 2
       double temp = key * A;
       double frac = temp - floor(temp);
       return floor(tableSize * frac);
   }
   ```
   **특징:**
   - 키의 분포에 덜 민감
   - Division Method보다 더 균등한 분포
   - 부동소수점 연산으로 인해 약간 느림

3. **Universal Hashing**
   ```cpp
   int hash(int key, int tableSize, int a, int b, int p) {
       return ((a * key + b) % p) % tableSize;
   }
   ```
   **특징:**
   - 무작위로 선택된 해시 함수 사용
   - 최악의 경우 입력에 대한 보호
   - p는 소수여야 함

4. **String Hashing (문자열용)**
   ```cpp
   // djb2 알고리즘
   unsigned long hash(const char* str) {
       unsigned long hash = 5381;
       int c;
       while (c = *str++)
           hash = ((hash << 5) + hash) + c; // hash * 33 + c
       return hash;
   }
   
   // FNV-1a 알고리즘
   uint32_t hash(const char* str) {
       uint32_t hash = 2166136261u;
       while (*str) {
           hash ^= *str++;
           hash *= 16777619u;
       }
       return hash;
   }
   ```
   **특징:**
   - djb2: 문자열에 대해 좋은 분포
   - FNV-1a: 빠른 계산과 좋은 분포
   - 충돌이 적고 빠른 계산 가능

5. **Custom Object Hashing**
   ```cpp
   struct Point {
       int x, y;
       
       size_t hash() const {
           return std::hash<int>{}(x) ^ 
                  (std::hash<int>{}(y) << 1);
       }
   };
   ```
   **특징:**
   - 사용자 정의 타입에 대한 해시
   - 여러 필드를 조합하여 해시값 생성
   - std::hash 특수화로 STL 컨테이너 사용 가능

### 좋은 해시 함수의 조건

1. **결정성 (Deterministic)**
   - 같은 입력에 대해 항상 같은 출력 생성
   - 예측 가능한 동작 보장

2. **균등 분포 (Uniform Distribution)**
   - 출력값이 해시 테이블에 고르게 분포
   - 충돌 최소화

3. **효율성 (Efficiency)**
   - 계산이 빠르고 간단
   - 최소한의 메모리 사용

4. **연속성 (Continuity)**
   - 비슷한 입력에 대해 전혀 다른 해시값 생성
   - 패턴 형성 방지

### 실제 활용 예시

1. **암호화 해시 함수 (보안용)**
   ```cpp
   #include <openssl/sha.h>
   
   std::string sha256(const std::string& str) {
       unsigned char hash[SHA256_DIGEST_LENGTH];
       SHA256_CTX sha256;
       SHA256_Init(&sha256);
       SHA256_Update(&sha256, str.c_str(), str.size());
       SHA256_Final(hash, &sha256);
       
       std::stringstream ss;
       for(int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
           ss << std::hex << std::setw(2) << std::setfill('0') 
              << (int)hash[i];
       }
       return ss.str();
   }
   ```

2. **파일 체크섬 (무결성 검사용)**
   ```cpp
   uint32_t crc32(const char* data, size_t length) {
       uint32_t crc = 0xFFFFFFFF;
       while (length--) {
           char c = *data++;
           for (uint32_t i = 0x80; i > 0; i >>= 1) {
               bool bit = crc & 0x80000000;
               if (c & i) {
                   bit = !bit;
               }
               crc <<= 1;
               if (bit) {
                   crc ^= 0x04C11DB7;
               }
           }
       }
       return crc;

**충돌 해결 방법:**

1. Chaining
   **장점:**
   - 구현이 간단
   - 삭제가 쉬움
   - 적재율이 높아도 성능 저하가 적음
   
   **단점:**
   - 추가 메모리 필요
   - 캐시 성능이 떨어질 수 있음

2. Open Addressing
   **장점:**
   - 메모리 사용이 효율적
   - 캐시 성능이 좋음
   
   **단점:**
   - 군집화 문제 발생 가능
   - 삭제 구현이 복잡
   - 적재율이 높으면 성능 저하

**해시 함수 선택 시 고려사항:**
1. 균등 분포
2. 계산 속도
3. 최소한의 충돌
4. 연속된 키에 대한 분산도

**활용 사례:**
- 데이터베이스 인덱싱
- 캐시 시스템
- 블룸 필터
- 중복 검사

## 실무 활용 가이드

### 상황별 최적 자료구조 선택:

1. **빈번한 검색이 필요한 경우:**
   - 작은 데이터셋: 해시 테이블
   - 큰 데이터셋: B-Tree
   - 범위 검색 필요: Red-Black Tree

2. **우선순위 기반 처리:**
   - 단순 우선순위: 힙
   - 복잡한 우선순위: Red-Black Tree

3. **메모리 제약이 있는 경우:**
   - 인접 리스트 기반 그래프
   - Open Addressing 해시 테이블

4. **실시간 처리가 필요한 경우:**
   - Red-Black Tree
   - 힙 (우선순위 큐)

### 성능 최적화 팁:

1. **메모리 관리:**
   - 적절한 초기 용량 설정
   - 재할당 최소화
   - 메모리 단편화 고려

2. **캐시 효율성:**
   - 연속된 메모리 선호
   - 노드 크기 최적화
   - 캐시 라인 고려한 설계

3. **동시성 처리:**
   - Lock-free 알고리즘 고려
   - 세밀한 락킹 전략
   - 동시성 레벨에 따른 자료구조 선택


## 시간 복잡도 비교

주요 자료구조들의 시간 복잡도를 비교하면 다음과 같습니다:

| 자료구조 | 검색 | 삽입 | 삭제 | 공간 복잡도 |
|----------|------|------|------|------------|
| Red-Black Tree | O(log n) | O(log n) | O(log n) | O(n) |
| AVL Tree | O(log n) | O(log n) | O(log n) | O(n) |
| B-Tree | O(log n) | O(log n) | O(log n) | O(n) |
| Hash Table | O(1)* | O(1)* | O(1)* | O(n) |
| Binary Heap | O(n) | O(log n) | O(log n) | O(n) |

* 평균 케이스. 최악의 경우 O(n)

## 면접 예상 질문과 답변

### Q1: Red-Black Tree와 AVL Tree의 차이점은 무엇인가요?

**A:** 
- AVL Tree는 더 엄격한 균형 조건을 가집니다 (높이 차이가 최대 1).
- Red-Black Tree는 더 느슨한 균형을 허용하지만, 색상 규칙을 통해 균형을 유지합니다.
- AVL Tree는 더 빠른 검색을 제공하지만, Red-Black Tree는 더 효율적인 삽입/삭제를 제공합니다.
- 실제 응용에서는 Red-Black Tree가 더 많이 사용됩니다 (예: STL의 map, set).

### Q2: B-Tree가 데이터베이스에서 자주 사용되는 이유는 무엇인가요?

**A:**
- 디스크 접근을 최소화하도록 설계되었습니다.
- 한 노드에 여러 키를 저장할 수 있어 디스크 I/O를 줄일 수 있습니다.
- 항상 균형을 유지하여 안정적인 성능을 보장합니다.
- 범위 검색에 효율적입니다.

### Q3: Hash Table의 충돌 해결 방법에는 어떤 것들이 있나요?

**A:**
1. Chaining (연결 리스트 사용)
   - 각 버킷에 연결 리스트를 사용하여 충돌된 항목들을 저장
   - 메모리 사용이 유동적
   
2. Open Addressing
   - Linear Probing: 다음 빈 슬롯을 순차적으로 검색
   - Quadratic Probing: 제곱수만큼 건너뛰며 검색
   - Double Hashing: 두 번째 해시 함수를 사용하여 다음 위치 결정

### Q4: 힙(Heap)이 우선순위 큐 구현에 적합한 이유는 무엇인가요?

**A:**
- 최대/최소 원소에 대한 빠른 접근 (O(1))
- 삽입과 삭제가 효율적 (O(log n))
- 완전 이진 트리 구조로 메모리 사용이 효율적
- 배열로 구현 가능하여 캐시 친화적
